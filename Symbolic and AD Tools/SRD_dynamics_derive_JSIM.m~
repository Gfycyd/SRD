function H = SRD_dynamics_derive_JSIM(varargin)
Parser = inputParser;
Parser.FunctionName = 'SRD_dynamics_derive_JSIM';
Parser.addOptional('SymbolicEngine', []);
% Parser.addOptional('Symbolic_UseParallelizedSimplification', false);

Parser.parse(varargin{:});

if isempty(Parser.Results.SymbolicEngine)
    error('Please provide SymbolicEngine')
else
    SymbolicEngine = Parser.Results.SymbolicEngine;
end

disp('* Derivation of JSIM started');

% H*ddq + c = T*u;        ddq = dv/dt; v = dq/dt;
%
% H = sum(  J'*m*J +Jw'*I*Jw  )


if SymbolicEngine.Casadi
    H = zeros(SymbolicEngine.dof, SymbolicEngine.dof);
else
    H = sym(zeros(SymbolicEngine.dof, SymbolicEngine.dof));
end

for i = 1:length(SymbolicEngine.LinkArray)
    
    H = H + SymbolicEngine.LinkArray(i).Jacobian_CenterOfMass' * ...
            SymbolicEngine.LinkArray(i).Mass * ...
            SymbolicEngine.LinkArray(i).Jacobian_CenterOfMass ... 
            + ...
            SymbolicEngine.LinkArray(i).Jacobian_AngularVelocity' * ...
            SymbolicEngine.LinkArray(i).Inertia * ...
            SymbolicEngine.LinkArray(i).Jacobian_AngularVelocity;
    
end

if SymbolicEngine.Casadi
    disp('Started simplifying joint space inertia matrix (JSIM) of the mechanism');
    H = obj.Math.simplify(H, 'JSIM');
end


if SymbolicEngine.Casadi
    iH = add_iH_variable(n);
    
    TCq = jacobian(T*u+c, q);
    TCv = jacobian(T*u+c, v);
    
    
    dfdq = -iH*reshape(jacobian(H(:), q)*(iH*(T*u+c)), n, n) + ...
        TCq;
    
    dfdv = iH * TCv;
    
    A = [zeros(n, n), eye(n);
        dfdq,        dfdv];
    
    B = [zeros(n, m);
        iH*T];
    
    linear_c = [zeros(n, 1);
        iH*c - dfdq*q - dfdv*v];
    
    generate_functions_Casadi(A, B, linear_c, iH, Parser);
    description.Casadi_cfile_name = Parser.Results.Casadi_cfile_name;
else
    tic
    iH = sym('iH', [n, n]);

    TCq = jacobian(T*u+c, q);
    disp('Simplifying TCq');
    TCq = simplify(TCq);
        
    TCv = jacobian(T*u+c, v);
    disp('Simplifying TCv');
    TCv = simplify(TCv);
    
    
    dfdq = -iH*reshape(jacobian(H(:), q)*(iH*(T*u+c)), n, n) + ...
        TCq;
    disp('Simplifying dfdq');
    dfdq = simplify(dfdq);
    
    dfdv = iH * TCv;
    disp('Simplifying dfdv');
    dfdv = simplify(dfdv);
    
    A = [zeros(n, n), eye(n);
         dfdq,        dfdv];
     
    B = [zeros(n, m); 
         iH*T];
     
    linear_c = [zeros(n, 1); 
                iH*c - dfdq*q - dfdv*v];
            
    disp('Simplifying A');
    A = simplify(A); 
    disp('Simplifying B');
    B = simplify(B); 
    disp('Simplifying linear_c');
    linear_c = simplify(linear_c); 
    
    generate_functions_symbolic(A, B, linear_c, iH, Parser);
    toc
end    
            
description.Path  = Parser.Results.Path;
description.FunctionName_A  = Parser.Results.FunctionName_A;
description.FunctionName_B  = Parser.Results.FunctionName_B;
description.FunctionName_c  = Parser.Results.FunctionName_c;

description.dof_configuration_space_robot = n;
description.dof_state_space_robot = 2*n;
description.dof_control = m;

disp('* Linearization finished');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% function generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    
end